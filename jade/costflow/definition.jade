
section
  +slide
    h1 Definition

  +slide
    h2 最小花費最大流的定義

    p 和最大流時一樣，我們要求一個流量最大的流。
    p 但現在每個邊除了有流量上限以外，還有一個價格 \( k(u, v) \)，
      | 表示每單位流過要付多少錢。
    p 最後總花費是
      | \[ k(f) = \sum_{f(u, v) > 0} k(u, v) \cdot f(u, v) \]

  +slide
    p 如何修改前面的使得可以找一個最小花費的最大流？
    p 我們先想剩餘網路要怎麼做修改。
    p 流量應該不變。
    p 那剩餘網路的花費 \( k_{f} (u, v) \) 如何設？

  +slide
    p 如果在原圖有一條有向邊 \( u \to v \) ， Cost 為 \( k(u, v) \)。
    ul
      li.fragment 順流： 在剩餘網路上流一單位，表示在原來的流上增加一單位。
        | \[ \implies k_f(u, v) = k(u, v) \]
      li.fragment 逆流： 在剩餘網路上反著流一單位，表示在原來的流上減少一單位。
        | \[ \implies k_f(v, u) = -k(v, u) \]

  +slide
    +theorem({name: ''})
      | 一個最大流 \( f \) 是一個最小花費最大流若且唯若其剩餘網路上沒有
      b 負環
      | ，也就是花費為負的環。
    .blackboard

  +slide
    +theorem({name: ''}).
      如果在剩餘網路上沒有負環，現在我們找一個花費最小的路徑擴充，則擴充後
      剩餘網路上還是不會有負環。
    .blackboard

  +slide
    p 由這兩個引理我們可以知道只要每次都找最短路擴充，直到最大流即可。
    p.fragment 只是現在「最短路」並非邊數最少的路徑，而是花費總合最少的路徑！ 

  +slide
    h3 Psuedo Code
    pre
      code.cpp.
        int f = 0
        while (tf = find_mincost_path()) {
            f += tf;
        }
        return f;

  +slide
    h2 Finding min-cost path
    p 可以用任何能處理負邊的演算法，如 SPFA。
    p 總複雜度是 \( \ord{SP \cdot \abs{F}} \)。


